\chapter{Solution d'administration à distance d'objets connectés}
\label{sec:content}

\section{Nécéssité de cette solution}

La société Y3S developpe toute sorte d'objets connectés comme des centrales d'alarmes, sondes de relevé de température et tous hébergent un serveur HTTP local pour sa gestion ou son utilisation, malheureusement pour accéder à son contenu local depuis internet il faut ouvrir les ports et configurer les routeurs sur lequel nous y avons connecté l'objet. Pour les grandes entreprises ou collectivités il n'est pas toujours possible d'effetuer ce genre de modification à leur architecture réseau à cause de problèmes de sécurité, de compétence ou tout simplement parce que le nombre d'objets connectés est trop important pour recevoir ces configurations manuellement pour chaque unité.

Une autre solution consiste à developper un CLOUD sur lequel se connectent tout les objets connectés et permettant aux utilisateurs d'y accéder par l'intermédiaire d'un frontend HTTP par exemple. Cette solution reste extrêmement couteuse, en effet elle nécessite de développer une solution CLOUD spécifique à chaque service ou type d'objet connecté.

C'est donc dans cette optique que l'entreprise recherche une solution qui permettrerai de remplacer le CLOUD par une solution plus générique qui donnerait directement accès aux services locaux hébergés directement sur l'objet connecté, réduissant ainsi les coût en developpement et installation.

\section{Spécifications}

\subsection{Spécifications fonctionnelles}

Il est necessaire de développer la solution en deux partie, le client a installé sur l'objet et le serveur backend en charge de rendre l'objet connecté accesible sur internet. La solution doit être capable de fournir un client ou un SDK à installer sur l'objet connecté, qui permet permet de se connecter au serveur backend de la solution. Les principales fonctionnalités de la solution sont :

\begin{itemize}
    \item Générer un nom de domaine unique par objet connecté qui hébergent un serveur HTTP.
    \item Gérer les déconnexion, reconnexion de l'objet connecté, pointer sur une page HTML d'erreur si on tente d'accéder au nom de domaine d'un objet déconnecté et founir un nouveau nom de domaine unique si l'objet est resté deconnecté jusqu'à l'écoulement d'un délais prédéfini, sinon lui resservir le même nom de domaine.
    \item Pouvoir se reconnecter automatiquement à un des serveurs s'il perd la connexion.
    \item La solution ne doit pas se contenter d'un seul seule protocole tel que le HTTP, mais doit pouvoir relayer n'importe quel protocole utilisant le TCP.
\end{itemize}

\subsection{Contraintes}

Le monde des objets connectés utilise des architectures de processeur spécifiques et variés. La solution cliente doit donc être multi-plateforme, elle doit fonctionner sur UNIX, Windows, Android sur des architectures x86/x64, ARM, MIPS. On doit pouvoir aussi réimplémenter le client sur microcontrôleur possèdant une stack IP parce qu'il sont très utilisés dans le monde de l'industrie et donc des objets connectés.

Certaine entreprise ont des pare-feux très restrictifs ne permettant la sortie que de certain protocole comme le HTTP et HTTPS respectivement sur le port 80 et 443.

\subsection{Spécifications techniques}

Pour répondre aux besoins de la solution, des choix techniques ont étés fait tout le long du developpement du prototype de la solution. Au début Y3S m'a demandé de comparer les solutions existantes de Reverse Tunneling, qui leur semblait être la technique la plus pertinente, particulièrement si la solution utilise les websockets.

J'ai personnellement choisi de développer le client en C++, un langage bas niveau orienté objet qui reste facile à compiler sur plusieurs architectures. Le serveur a été développé en nodejs pour sa simplicité de mise en place et de developpement, sa scabilité et sa maintenance.

Pour résumer, voici les technologies techniques utilisés actuellement sur le prototype à la fin de son développement, leur justification d'utilisation suivra dans le rapport :

\begin{itemize}
    \item Reverse Tunneling en websocket : transfert de protocole TCP à travers n'importe quel routeur, pare-feu qui accepte le HTTP/HTTPS.
    \item C++ et socket natif : développement client.
    \item Node.js : développement serveur.
    \item Redis : base de données.
    \item OpenResty : proxy HTTP dynamique.
\end{itemize}

\section{Principe du Reverse Tunneling}

Pour illustrer le principe du reverse tunneling je vais me servir d'un scénario. Imaginons que nous souhaitons atteindre le serveur HTTP d'Alice, mais Alice est derrière un NAT qui bloque toute les connexions entrantes sur son réseau. Malheureusement elle n'a pas la main sur son routeur, ce qui nous empêche naturellement toute modification du réseau. Par contre Bob à le contrôle de son réseau, qui accepte les connexion entrante sur sa machine, ce qui va nous permettre de procéder en sens inverse. C'est Alice que nous souhaitons joindre qui va créer une connexion vers Bob que nous appelerons tunnel. En effet il suffit à Bob d'écouter sur le port de son choix qu'Alice connait, il attend qu'Alice se connecte dessus et lui transmet sa requête HTTP. De son côte Alice va recevoir la requête HTTP de Bob, qu'elle relaye à son serveur HTTP et renvoit la réponse HTTP par cette même connexion. C'est pour cela que cela s'appelle du reverse tunneling, c'est notre cible qui est à l'initiative de la connexion, autrement dis du tunnel.

\section{Comparaison de solution de reverse tunnel}

Après quelque jours de recherche, j'ai retenu trois solutions de reverse tunnel :

\begin{itemize}
    \item OpenSSH
    \item Etherws
    \item Node Reverse Wstunnel
\end{itemize}

\subsection{OpenSSH}

OpenSSH est une suite d'outils SSH libre mettant à disposition un client et server SSH très complet. Hors le SSH permet d'initialiser un tunnel directement avec une commande SSH. Pour en revenir sur notre scénario précédent. Bob installe un serveur SSH sur sa machine (en 22), toujours accessible de l'extérieur par le nom de domaine bob.fr et rajoute sur son serveur SSH l'utilisateur alice. Elle va s'y connecter en précisant qu'elle ouvre un tunnel inverse de son port 80 sur lequel écoute son serveur HTTP, jusqu'au port de son choix par exemple le 8080. Bob peut desormais accéder au serveur d'Alice en remontant le tunnel par l'adresse http://localhost:8080.

\noindent L'action se résume par cette unique ligne de commande qu'Alice exécute sur sa machine :
\begin{lstlisting}[language=bash]
  $ ssh -NR 8080:localhost:80 alice@bob.fr
\end{lstlisting}

Bien évidemment cela fonctionne pour n'importe quel service en TCP, il suffit juste de choisir le bon port.

Avantages :
\begin{itemize}
    \item Facile à mettre en place.
    \item Automatiquement sécurisé.
\end{itemize}

Inconvénients :
\begin{itemize}
    \item Les microcontrôleur ne possède pas de client SSH, en développer un serait périlleux.
    \item Pour chaque port ouvert il faut une nouvelle connexion SSH.
    \item Un serveur SSH n'est pas optimiser pour maintenir une centaine de connexion permanente.
    \item Le port d'entrée et sortie du tunnel est choisi par le client.
\end{itemize}

\subsection{Etherws}

Etherws est un mini VPN utilisant des websockets comme tunnel, il est entièrement développé en python. La configuration se fait en deux étapes, d'abords la création de l'interface virtuel en TUN/TAP avec l'adressage de l'IP virtuel, puis la connexion au serveur (toujours celui de Bob qui est le seul à disposé d'un nom de domaine public). Le fait d'utiliser une interface virtuel permet d'utiliser tout les ports à la fois sans en préciser un en particulier qui doit être relié à un autre distant sur la machine de Bob.

Dans notre cas Alice va choisir d'appeler son interface virtuel \og etherws0 \fg{} avec l'IP \og 10.0.2.8 \fg{} et se connecter sur le serveur etherws de Bob (en 80). Pour accéder au serveur HTTP d'Alice, Bob doit remonter le tunnel en passant par l'IP virtuel d'Alice, soit comme cela http://10.0.2.8:80.

\noindent Commande nécessaire à la création du tunnel :
\begin{lstlisting}[language=bash]
  # etherws sw
  # etherws ctl addport tap ethws0
  # etherws ctl setif --address 10.0.2.8 --netmask 255.255.255.0 1
  # etherws ctl addport client ws://bob.fr/
\end{lstlisting}

Avantages :
\begin{itemize}
    \item Utilise les websockets.
    \item Peut être sécurisé en SSL/TLS.
\end{itemize}

Inconvénients :
\begin{itemize}
    \item Monte une interface virtuel.
    \item L'IP virtuel est choisi par le client.
    \item Tout les clients peuvent communiquer ensemble par le réseau virtuel.
    \item Portage difficile, voir impossible sur microcontrôleur.
\end{itemize}

\subsection{Node Reverse Wstunnel}

Node Reverse Wstunnel est un tunnel inversé développé en javascript avec Node.js, utilisant les websockets. Il s'utilise sur le même principe que le tunnel inversé SSH mais en passant par un tunnel websocket au lieu d'un tunnel SSH. Bob lance sur sa machine le serveur tunnel inversé en 80 (avec node) et Alice s'y connecte avec le client fourni en précisant les deux ports qu'elle veut relier.

\noindent Si on reprend la même configuration que pour le tunnel SSH, la commande qu'Alice doit exécuter est :
\begin{lstlisting}[language=bash]
  $ ./wstt.js -r 8080:localhost:80 ws://bob.fr/
\end{lstlisting}

Bob peut donc accéder au serveur HTTP d'Alice en se connectant en http://localhost:8080.

Avantages :
\begin{itemize}
    \item Utilise les websockets.
    \item Peut être sécurisé en SSL/TLS.
\end{itemize}

Inconvénients :
\begin{itemize}
    \item Le port d'entrée et sortie du tunnel est choisi par le client.
\end{itemize}

\subsection{Choix final}

Finalement nous avons décidé de choisir la solution de reverse tunneling en Node.js en websocket, mais en reprogrammant le client en C++ parce que le Node.js n'est pas portable sur toute les versions d'ARM. Le serveur restera en Node.js mais sera re-écris pour mieux répondre à nos besoins, c'est en effet une technologie facilement maintenable pour développer un serveur websocket évolutif. L'architecture de base de Node Reverse Wstunnel est la seule chose conservé dans son intégrité.

\section{Proxy HTTP dynamique}

Nous avons résolu comment accéder à une machine distante sans modifier son NAT ou connaître son IP. Cependant notre objectif est d'accéder à plusieurs machines, objets connectés à travers un nom de domaine unique pour chaque. Actullement si je reprends l'exemple précédent d'Alice et Bob. Alice fait tourner son serveur HTTP sur le port 80, en se connectant au serveur wstunnel de Bob, elle a demandé à relier son port 80 avec le port 8080 de Bob. Ainsi depuis internet, si on se connecte en http://bob.fr:8080 on accéde au serveur HTTP d'Alice, car Bob possède un nom de domaine qui pointe sur l'IP fixe de sa machine. Cela fonctionne parfaitement sauf qu'on voulait un nom de domaine sans devoir préciser le port, certes on pourrait déplacer le serveur wstunnel sur le port 8080 et remettre le tunnel du port 80 d'Alice au port 80 de Bob comme cela le nom de domaine serait bob.fr tout simplement. Mais qu'arriverait il si nous souhaitons rajouter une ou dix autre machine dans le même cas qu'Alice ? Il nous faudra bien utiliser des ports autre que le 80.

C'est pour résoudre ce problème que j'ai dû installer un proxy HTTP. Celui-ci est en fait un serveur HTTP qui va rediriger une requête ou une réponse HTTP sur un autre port en fonction du nom de domaine. Quand nous rentrons un nom de domaine dans un navigateur, celui-ci va résoudre le nom de domaine en IP et envoyer une requête HTTP sur cette IP, port 80 par défaut. C'est grâce à la requête HTTP que le proxy peut connaître le serveur cible sur lequel rediriger la requête. En effet une requête HTTP contient un champs \og Host \fg qui contient le nom de domaine que l'utilisateur a saisi dans le navigateur, le proxy redirige donc en fonction de ses configurations sur tel ou tel port la requête et la réponse HTTP.

Dans notre cas Bob peut configurer son proxy HTTP qui écoute sur le port 80 de rediriger le nom de domaine \og alice.bob.fr \fg en \og localhost:8080 \fg (le serveur wstunnel est sur un autre port disponible).

\noindent Exemple de requête HTTP :
\begin{lstlisting}[language=bash]
  GET / HTTP/1.1
  Host: alice.bob.fr
\end{lstlisting}

Malheureusement la plus part des proxy HTTP sont configurables à l'arrêt, ce qui veut dire que si nous voulons rediriger d'autre serveur HTTP comme Alice, nous devons éditer les configurations du proxy et redémarrer les services, le tout manuellement, ce qui est tout simplement impossible pour les objectifs de notre solutions de pouvoirs rediriger des centaines de nom de domaines unique pour autant d'objets connectés. Il m'a fallu rechercher un solution dynamique à notre problème.

OpenResty est un serveur, proxy HTTP basé sur Nginx, qui à la particularité d'être très modulables grâces à ces nombreux modules configurables et à la possibilité d'exécuter des scripts LUA lorsque l'on reçoit une requête HTTP. LUA est un langage de scripting très léger et facile à embarquer. Avec OpenResty j'ai pu écrire une configuration de proxy qui lorsque qu'il reçoit une requête, recherche \og Host \fg{} dans notre base de données et si ce nom de domaine existe dans la base alors rediriger la requête vers l'IP et port associés. Tout cela est possibles grâce à un script LUA qui se connecte à la base de données, de plus nous pouvons rajouter des noms de domaines à rediriger dans la base de données sans à devoir redémarrer le proxy. OpenResty nous a donc permis de créer un proxy HTTP dynamique.

\section{Base de données Redis}

Pour faire fonctionner l'ensemble de notre solution, il a fallut faire le choix d'une base de données central qui ferait le lien entre le proxy HTTP dynamique et le serveur wstunnel en Node.js, mais aussi avec la futur partie front-end, en charge d'afficher la liste des ports rediriger pour chaque client et le nom de dommaine unique si c'est un port 80 ou 443. J'ai fais le choix d'utiliser Redis, qui est une base de données No-SQL dont la particularité est de stocker tout son contenu dans la mémoire vive. Redis utilise des structures de données très simple comme des listes, des ensembles, des tableaux associatifs ou même des ensembles triés. Elle peut en stocker des dizaines de millions de clefs et valeurs dans à peines 100 Mio de RAM. Son protocole de communication, ses structures et son stockage en RAM ont fait d'elle une base de données extrement rapide, c'est justement ce qu'il nous faut pour que notre proxy HTTP dynamique réponde le plus rapidement possible aux requêtes. Une petite fonctionnalité de Redis permet aussi de rajouter un délais d'expiration sur certaines valeurs stockés avant leur suppression, cela c'est avérait pratique pour supprimer automatiquement les noms de domaines et ports qui n'etait plus utilisés par l'objet connecté qui s'est justement déconnectés, une fonctionnalité qui nous permet donc de libérer les ports non utliser et regagner en capacité. Par contre si l'objet connecté se reconnecte avant la fin du délais, alors il conservera son ports et son nom de domaine alloué.

\section{Modification et Re-developpement du Tunnel WebSocket}

\subsection{WebSocket}

Le websocket est un protocole réseau standard du Web visant à créer une communication full-duplex sur une connexion HTTP, donc en TCP. Ce protocole a été normalisé dans la RFC 6455, son but est de pouvoir établir des communications bidirectionnelles avec un long temps de vie entre le client et serveur HTTP afin de notifier le client d'un changement d'état du serveur ou même d'envoyer des données ponctuel du serveur au client.

Pour initialiser une connexion, websocket il faut envoyer une requête HTTP spécifique au serveur qu'on appelle le \og Handshake \fg{} au quel le serveur doit répondre avec une réponse HTTP. Ensuite à partir de cette échange, la connexion HTTP passe en connexion websocket.

\noindent Exemple de requête handshake :
\begin{lstlisting}[language=bash]
  GET /chat HTTP/1.1
  Host: example.com:8000
  Upgrade: websocket
  Connection: Upgrade
  Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
  Sec-WebSocket-Version: 13
\end{lstlisting}

\noindent Exemple de réponse handshake :
\begin{lstlisting}[language=bash]
  HTTP/1.1 101 Switching Protocols
  Upgrade: websocket
  Connection: Upgrade
  Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
\end{lstlisting}

Lors du handshake le client passe dans la requête HTTP le champs \og Sec-WebSocket-Key \fg{} qui contient une clef aléatoirement généré par le client et cryptée en base64. Le serveur doit hasher en SHA1 la concaténation de cette clef avec une chaîne de caractère prédéfini dans la RFC 6455 et convertir la sortie en base64, ce qui correspond dans la réponse au champs \og Sec-WebSocket-Accept \fg{}. Le client doit ou peut réaliser la même opération pour vérifier qu'il communique bien avec un serveur websocket et non un proxy qu'il lui renverrait un simple cache.

La suite de la communication est entièrement basé sur des trames websocket binaire, rythmé par des échanges de trames de controle ping et pong dit \og battement de coeur \fg{}, pour avoir la certitude que le la connexion est toujours active. Je ne vais pas détailler d'avantage les trames websocket car cela est peu utile et très spécifique, il suffit de lire la RFC 6455, je rajouterai seulement que le webscoket permet d'envoyer deux type de données, du texte brute UTF-8 et du binaires.

\subsection{Fonctionnement}

Pour expliquer le principe de fonctionnemment du tunnel en websocket (qui sera toujours en mode \og reverse \fg{}) qu'on applera plus facilement le tunnel, sans pour l'instant y ajouter le proxy HTTP dynamque, je vais en rédéfinir les acteurs, il y en a trois principaux :
\begin{itemize}
    \item Le serveur, c'est le serveur websocket principal qui pilote tout le tunnel, son IP est donc connu et public. Il est connectés à la base de données Redis, sur laquel il stock les ports alloué et connexions courantes.
    \item Le client, c'est la machine ou objet connecté souhaitant rendre accessible un de ses serveurs au public, dans notre cas se sera un serveur HTTP.
    \item Le navigateur, c'est un utilisateur externe qui veut accéder au service du client, dans notre cas il fera une requête HTTP sur un port définis du serveur websocket. 
\end{itemize}

Pour faire fonctionner le tunnel il faut au minimum deux connexions websocket, la première est le websocket de contrôle, il sert à initialiser et avertir le client d'une nouvelle connexion du navigateur. Dans le handshake du websocket de contrôle, il faut passer dans l'URL les paramètres suivant, le nom du client et les ports qu'il souhaite faire passer. Le serveur va allouer au client un port disponible sur sa machine ou bien lui donner un port qu'il a déjà utilisé lors de sa précédente connexion mais qui n'a pas encore expiré. Le serveur va monter ce nouveau port allouer comme serveur TCP et y attendre une connexion. Bien sur si un client avec le même nom est déjà connecté la connexion sera refusé. C'est ce que j'appelle la phase d'initialisation du tunnel. Maintenant un navigateur qui connait le port allouer au client sur le serveur va se connecter dessus et y effectuer une requête HTTP. Le serveur va accepté la connexion étant donné qu'une requête HTTP utilise le TCP, il va mettre en attente le navigateur, tagger cette connexion avec un ID unique et envoyer un message sur le websocket de contrôle au client associé à ce port alloué. Ce message est très simple, il contient simplement le port qui a été associé à cette allocation de port lors de la phase d'initialisation du tunnel, soit le port 80 pour un serveur HTTP et l'ID de la connexion du navigateur. En recevant ce message par le websocket de contrôle le client va créer un nouvelle connexion websocket sur le serveur, que j'appelle le websocket de transfert, mais cette fois l'URL du handshake contiendra en paramètre l'ID associé à la connexion du navigateur. Il va aussi créer une connexion local vers son serveur HTTP et la relier au nouveau websocket de transfert, parce que le message reçu indiqué une redirection sur le port 80. Ainsi le serveur quand il va recevoir la connexion websocket saura exactement que c'est un websocket de transfert grâce à l'ID dans l'URL associé à la connexion du navigateur en cours. Maintenant que le tunnel est completement formé le serveur va rediriger la requête du navigateur dans le websocket de transfert associé en mode binaire, qui va lui même la rediriger côté client au serveur HTTP. Celui-ci va répondre en envoyant une réponse HTTP qui va faire le chemin inverse. Une fois la réponse arrivé jusqu'à son destinataire, le navigateur va fermé la connexion TCP, ce qui va fermé également le websocket de transfert associé à cette connexion ainsi que la connexion local au serveur HTTP du client. Seul restera le websocket de contrôle et le serveur TCP monté sur le port alloué, qui attendront une nouvelle connexion d'un navigateur. Du fait que les connexion du navigateur soit taggé d'un ID unique, plusieurs connexion peuvent être traités à la fois, ce qui entraine autant de websocket de transfert que de connexion des navigateurs, voilà pourquoi le websocket de contrôle n'est là que pour avertir des nouvelles connexions et ne fais pas aussi le transfert des requêtes. Si c'était le cas il y aura trop d'attente entre chaque requête. Lorsque que le client va fermer la connexion du websocket de contrôle alors le serveur TCP associé au port alloué au client va se fermer et le port prendra un délais d'expiration dans la base de données Redis.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "isae-report-template"
%%% End: 
